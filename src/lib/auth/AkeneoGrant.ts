import { AkeneoGrantResponse } from './types'

/**
 * Holds the details of the grant returned from akeneo in response
 * to an authorisation API related request:
 * https://docs.akeneo.com/api/authorization
 */
export class AkeneoGrant {
  /**
   * The access token string needed when making requests to akeneo. If this
   * was generated by a customer logging in, then this is used by akeneo
   * to identify the customer.
   */
  public accessToken = ''

  /**
   * The refresh token is required for refreshing an existing grant. A refresh token
   * is only issued for customer grants (either logged in or anonymous), an not for
   * client grants.
   */
  public refreshToken?: string

  /**
   * The duration of the access token in seconds (typically 48 hours)
   */
  public expiresIn = 0

  /**
   * This is the expiry date/time of the access token. This is calculated based
   * on the `expiredIn` property, and as such may be very slightly after the
   * internal akeneo expiry date (due to the time involved to receive
   * and process the response.
   */
  public expiresAt = new Date()

  /**
   * Create a new grant from grant data received back from akeneo.
   */
  constructor(data: AkeneoGrantResponse) {
    this.accessToken = data.access_token
    this.expiresIn = data.expires_in

    // This sets the `expiresAt` property to the calculated Date when the grant is due to expire.
    this.expiresAt = new Date(new Date().getTime() + 1000 * data.expires_in)

    // When a grant is refreshed, we don't get back a new token,
    // so we keep hold of the old one unless one is explicitly provided.
    if ('refresh_token' in data && data.refresh_token) {
      this.refreshToken = data.refresh_token
    }
  }

  /**
   * Calculates whether the grant is due to expire within a given number of
   * seconds. This is useful when deciding if the expiry date/time is close
   * enough to warrant pro-active renewal, rather than waiting for expiry.
   */
  public expiresWithin(refreshIfWithinSecs: number) {
    const cutoff = new Date().getTime() + refreshIfWithinSecs * 1000
    return this.expiresAt.getTime() < cutoff
  }
}
